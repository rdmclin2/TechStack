title: "c note"
tags:
---

# cc编译命令
cc是c语言编译器的统称，一般指向系统的c编译器，如gcc或clang。

- `cc program.c` 产生一个a.out的可执行程序，删除目标文件
- `cc main.c sort.c lookup.c` 编译并链接几个源文件，不删除目标文件
- `cc -c program.c` 编译单个c源文件，产生一个目标文件
- `cc -c program.c sort.c lookup.c` 编译多个c源文件，为每个文件产生一个目标文件
- `cc main.o sort.o lookup.o` 链接几个目标文件
产生可执行程序的命令均可以加上`-o name`选项重命名a.out

# cmakelist 和 makefile的区别
CMake是一个跨平台的软件，在很多平台可以使用。一般在windows下，我们会直接使用VS生成项目，在linux下面，我们也可以使用QT Creater生成项目，但是两个不同平台上面的项目不能相互移植。这就有了CMake的用武之地，我们可以先编写一个CMakeLists.txt文件，将需要的.h和.cpp文件包含进来，然后在不同的平台使用CMake调用各自的编译器生成各自的工程。

大家都知道，写程序大体步骤为：

1.用编辑器编写源代码，如.c文件。

2.用编译器编译代码生成目标文件，如.o。

3.用链接器连接目标代码生成可执行文件，如.exe。

但如果源文件太多，一个一个编译时就会特别麻烦，于是人们想到，为什么不设计一种类似批处理的程序，来批处理编译源文件呢，于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是makefile，所以编写makefile文件也是一个程序员所必备的技能。

对于一个大工程，编写makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成makefile呢，于是就出现了cmake工具，它能够输出各种各样的makefile或者project文件,从而帮助程序员减轻负担。但是随之而来也就是编写cmakelist文件，它是cmake所依据的规则。所以在编程的世界里没有捷径可走，还是要脚踏实地的。


# 实践建议
- 可以用while((ch=getchar())!=EOF && ch != '\n' )进行无用字符的读取。
- 为什么ch被声明为整形，而事实上我们用它看来读取字符？因为EOF是一个整型值。
- 确保数组有空间容纳终止符。
- if或者各种函数调用的括号首尾加空格，可以突出表达式的内容,参数之间也用空格隔开
- 应该使用 typedef而不是 #define来创建新的类型名，因为后者无法正确地处理指针类型。如:

```
#define d_ptr_to_char char *
d_ptr_to_char a,b
```
这里正确地声明了a，但b被声明为一个字符。
- malloc的时候sizeof（）切记不能写成typedef出来的值，而是`struct Node`

# 基本
- for(int i = 0; i< 100 ;i++) 在c99中才能使用，一般情况下需要先声明后使用
- 在提交题目前将无用的输出语句都去掉。
- 注意题目的输入格式 ，如`while(scanf("%f%f%f",&xc,&yc,&r) != EOF)`
- 注意floor和ceil返回的都是float，要取整得转成int
- 最好用double，效率和空间不是问题,在目前的硬件环境下，最好都用double。嵌入式除外
- 涉及比较，浮点数的题目的时候不要用float,用double，因为比较的时候差别有时候就是很小的。
- \#define的常量一般都大写，用于提醒它们不是不同的变量
- 函数原型中参数的名字不是必须的。
- 函数中变量可以声明为const,代表在函数中不会修改所传递的参数的值
- 在c语言中，数组参数按引用形式传递，标量和常量按值传递，因此对变量参数的任何修改都会在函数返回时丢失，但是修改数组参数中的元素时，就会被实际的修改。
- 字符串就是一串以NUL字节结尾的字符，例如字符串常量"Hello"在内存中占据6个字节的空间。
- 如果你要从函数中返回一个数组作为结构，只能通过数组传参。
- 在函数声明的数组参数中，不指定数组的长度。但函数没办法知道该数组的长度，如果确实需要数组的长度，它的值必须作为一个单独的参数传递给函数。
- 注意进行数组下标检查
- 声明指针的时候用`int *a`的方式，而不是`int* a`，因为`int* b, c, d`很容易让人以为把所有三个变量都声明为指向整形的指针，事实上并不是这样，应该`int *b, *c, *d`。
- 定义常量可以用const, 可以`const int a`,也可以`int const a`,但坚持用一种。可以在声明的时候对其进行初始化。当涉及指针时，`int const *pci`是一个指向整形常量的指针，可修改指针。`int  * const pci`是一个指向整形的常量指针，不可修改指针。记忆的时候看const靠近哪个，那个就是不变的。另外`int const * const pci`两个都不可以变。
- static 关键字可以使链接属性变成internal，被该源文件所私有，只对缺省为external的声明有效。extern关键字为一个标识符指定external链接属性
- 在任何代码块之外声明的变量总是存储在静态内存中，在程序运行之前创建。在代码块内部声明的变量的存储在堆栈中，称为自动变量。
- 在代码块内部声明的变量如果加上关键词static可以让它的存储类型从自动编程静态。

# stdlib库
- <stdlib.h> 头文件里包含了C语言的中最常用的系统函数
- EXIT_FAILURE 失败状态码
- EXIT_SUCCESS 成功状态码
- exit(retval) 用于正常退出程序


# stdio库
- <stdio.h>头文件定义了用于输入和输出的函数、类型和宏。
- while(scanf("%f %f %f",&xc,&yc,&r) != EOF)
- printf("a1=%c, a2=%d, b=%c, c=%d, d=%c\n", a, a, b, c, d);
- printf与scanf不同的是，scanf 的变量前要带一个&符号；&称为取地址符，也就是获取变量在内存中的地址。
- gets函数从标准输入读取一行文本并把它存储于作为参数传递给它的数组中，如gets(input)。
- 用puts输出字符串,把指定的字符串写到标准输出并在末尾添加一个换行符.
- 对于scanf必须小心，所有标量参数的前面必须加上一个"&"符号，数组参数前面不需要，但是如果数组参数中出现了下标引用，他们它的前面也必须加上"&"符号。用%s格式码输入值时，中间不能包含空白。因为使用所有格式码（除去%c）时，输入值之前的空白（空格，制表符，换行符）都会被跳过，值后面的空白标示该值的结束。
- 用putchar输出单个字符

# ctype库
- <ctype.h> 主要提供两类重要的函数：字符测试函数和字符大小转化函数。
- `extern int isspace(int c);`,ispace函数判断字符c是否为空白符
- `int isalpha (int c)`,isalpha测试字符是否为英文字母,为宏

# string库
- <string.h> 头文件里包含了C语言的最常用的字符串操作函数
- `extern char *strcpy(char *dest,char *src);`把src所指由NULL结束的字符串复制到dest所指的数组中。
- extern int strlen(char *s); 计算字符串s的长度，不包括NUL
- extern int strcmp(char *s1,char * s2);   当s1<s2时，返回值<0;当s1=s2时，返回值=0;当s1>s2时，返回值>0


# 数据类型
- char 用'',字符串用""
- 可以看出，ASCII 码将字符和整数联系起来了，你可以给 char 变量一个整数，也可以给 int 变量一个字符，它们可以相互转换。
- 对于无符号整数的声明,long和short同，
```
// 下面的两种写法都是正确的，使用 unsigned 时可以不写 int
unsigned int a=100;
unsigned a=999;
```
- short 一般占2个字节，int 占 4 个字节，long 也占 4 个字节，char 的长度始终都是1个字节，float 的长度为 4 个字节，double 占用 8 个字节，是双精度浮点数，忘了可以用sizeof求
- system("pause");可以用来暂停等待用户输入
- sizeof(14.67) 的结果是8，不错，因为小数默认的类型就是double。

# 运算
- 我们把诸如a++这样的操作叫做后自增，也就是先进行其他操作，再进行自增操作；而把++a叫做前自增，会先进行自增操作，再进行其他操作。一般使用后自增，防止前自增的错误

# Array
## decalare
- int array[5];

## initialize
- int array[5] = {1,2,3,4,5}; // no more than 5
- int array = {1,2,3,4,5}; //make an array that just hold the 5 numbers

## get the size of an array
- `int n = sizeof(array)/sizeof(*array);`


# 输入输出

- 如果仅仅是输入单个字符，也可以使用 getchar,注意getchar也是带有缓冲区的

float : %f   默认保留6位小数
double : %lf
int : %d
octal : %o
hexadecimal : %x
unsigned : %u

## 美观
%-9d中，d表示以十进制输出，9表示最少占9个字符的宽度，宽度不足以空格补齐，-表示左对齐。综合起来，%-9d表示以十进制输出，左对齐，宽度最小为9个字符。大家可以亲自试试%9d的输出效果。`%[flags][width][.precision]type`
flags
几种常见的标志字符
标志字符	含  义
- -	左对齐
- +	输出符号（正号或负号）
- 空格	输出值为正时冠以空格，为负时冠以负号
- #
 - 对c、s、d、u类无影响；
 - 对o类，在输出时加前缀o；
 - 对x类，在输出时加前缀0x；
 - 对e、g、f 类当结果有小数时才给出小数点

## 缓冲区
fflush(stdin);用来清空输入缓冲区，这是什么意思呢？

在内存中，有一块区域（比如512字节）专门用来保存用户输入的数据，遇到 scanf 时，程序会首先检查该区域是否有数据：
如果没有，就等待用户输入，用户从键盘输入的每个字符都会暂时保存到这里，直到按下回车键，输入结束，scanf 再从这里读取数据，赋值给变量。
如果有数据，哪怕是一个字符，scanf 也会直接读取，不会等待用户输入。

这块内存区域，就叫做缓冲区（Buffer），或者缓存（Cache）；又因为它是用来暂存用户输入的数据的，所以又叫输入缓冲区。

> 这里重点是告诉大家 scanf 是带有缓冲区的

# 取整
## floor
extern float floor(float x);

用法：#include <math.h>

功能：求不大于x的最大整数

说明：返回x的下限，如74.12的下限为74，-74.12的下限为-75。返回值为float类型。

## ceil
原型：extern float ceil(float x);

  用法：#include <math.h>

  功能：求不小于x的最小整数

  说明：返回x的上限，如74.12的上限为75，-74.12的上限为-74。返回值为float类型。
